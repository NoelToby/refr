<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Reranker Framework (ReFr): Reranker Framework</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Reranker Framework (ReFr)
   
   </div>
   <div id="projectbrief">Reranking framework for structure prediction and discriminative language modeling</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Reranker Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="welcome_sec"></a>
Welcome to the Reranker Framework!</h2>
<p>This package provides ways to train and use discriminative models in a reranking framework. There is some special handling for building discriminative language models.</p>
<h2><a class="anchor" id="contents_sec"></a>
Contents</h2>
<ul>
<li>
<a class="el" href="index.html#building_sec">Building and installation</a> <ul>
<li>
<a class="el" href="index.html#quick_start_subsec">Quick start</a> </li>
<li>
<a class="el" href="index.html#detailed_instructions_subsec">Detailed instructions</a> </li>
</ul>
</li>
<li>
<a class="el" href="index.html#whats_in_here_sec">What&rsquo;s in the installation directory</a> </li>
<li>
<a class="el" href="index.html#extracting_features_sec">Extracting features</a> <ul>
<li>
<a class="el" href="index.html#io_subsec">I/O</a> </li>
<li>
<a class="el" href="index.html#bootstrap_protobuf">Creating protocol buffer files</a> <ul>
<li>
<a class="el" href="index.html#candidate_set_creation_1">Method 1: Batch</a> </li>
<li>
<a class="el" href="index.html#candidate_set_creation_2">Method 2: Serial</a> </li>
</ul>
</li>
<li>
<a class="el" href="index.html#classes_subsec">Classes</a> </li>
<li>
<a class="el" href="index.html#building_a_feat_extractor_subsec">Building a FeatureExtractor</a> </li>
<li>
<a class="el" href="index.html#extract_features_subsec">Extracting Features (Finally!)</a> </li>
<li>
<a class="el" href="index.html#bonus_subsec">Bonus subsection: extracting features already sitting in a file</a> </li>
</ul>
</li>
<li>
<a class="el" href="index.html#training_a_model_sec">Training a model</a> </li>
<li>
<a class="el" href="index.html#running_a_model_sec">Running a model</a> </li>
<li>
<a class="el" href="index.html#appendix_sec">Appendix: Dynamic object instantiation</a> <ul>
<li>
<a class="el" href="index.html#appendix_cpp_example">An example: The way C++ does it</a> </li>
<li>
<a class="el" href="index.html#appendix_details">Some nitty gritty details: declaring factories for abstract types and registering concrete subtypes</a> </li>
<li>
<a class="el" href="index.html#appendix_language">The Factory language</a> </li>
<li>
<a class="el" href="index.html#appendix_putting_together">Putting it all together</a> </li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="building_sec"></a>
Building and installation</h2>
<h3><a class="anchor" id="quick_start_subsec"></a>
Quick start</h3>
<p>To build and install, run the following command sequence: </p>
<div class="fragment"><pre class="fragment"> ./configure ; make ; make install 
</pre></div><h3><a class="anchor" id="detailed_instructions_subsec"></a>
Detailed instructions</h3>
<p><b>Requirements</b>: </p>
<ul>
<li>
<code>autoconf</code> 2.68 or higher </li>
<li>
<code>automake</code> 1.11 or higher </li>
</ul>
<p>Additional requirements are checked by the supplied <code>configure</code> script; they comprise: </p>
<ul>
<li>
a recent version of Python (v2.4 or higher) </li>
<li>
<a href="http://code.google.com/p/protobuf/">Google Protocol Buffers</a> </li>
<li>
<code>pkg-config</code> (a requirement of Google Protocol Buffers) </li>
</ul>
<p>Please make sure you have at least the preceding three packages installed prior to building the ReFr.</p>
<p>To build the Reranker Framework package, you must first run the supplied <code>configure</code> script. Please run </p>
<div class="fragment"><pre class="fragment"> ./configure --<a class="code" href="namespacehadoop-run.html#a3935d70733fa64c4ad3b0526a8ced2b9">help</a> 
</pre></div><p> to see common options. In particular, you can use the <code>--prefix</code> option to specify the installation directory, which defaults to <code>/usr/local/</code>.</p>
<p>After running <code>./configure</code> with any desired options, you can build the entire package by simply issuing the make command: </p>
<div class="fragment"><pre class="fragment"> make 
</pre></div><p>Installation of the package is completed by running </p>
<div class="fragment"><pre class="fragment"> make install 
</pre></div><p>Finally, there are a number of additional make targets supplied &ldquo;for free&rdquo; with the GNU autoconf build system, the most useful of which is </p>
<div class="fragment"><pre class="fragment"> make clean 
</pre></div><p> which clean the build directory and </p>
<div class="fragment"><pre class="fragment"> make distclean 
</pre></div><p> which cleans everything, including files auto-generated by the <code>configure</code> script.</p>
<h2><a class="anchor" id="whats_in_here_sec"></a>
Whatâ€™s in the installation directory</h2>
<p>Executables are in the <code>bin</code> subdirectory, and a library is built in the <code>lib</code> subdirectory. There are many unit test executables, but the two &ldquo;real&rdquo; binaries you&rsquo;ll care about are: </p>
<div class="fragment"><pre class="fragment"> bin/extract-features 
</pre></div><p> and </p>
<div class="fragment"><pre class="fragment"> bin/run-model 
</pre></div><h2><a class="anchor" id="extracting_features_sec"></a>
Extracting features</h2>
<p>When dealing with feature extraction, you can work in an off-line mode, where you read in candidate hypotheses, extract features for those hypotheses and then write those back out to a file. You can also work in an on-line mode, where you train a model by reading in sets of candidates (hereafter referred to as &ldquo;candidate sets&rdquo;) where features for each candidate in each set are extracted &ldquo;on the fly&rdquo;. Finally, you can mix these two ways of working, as we&rsquo;ll see below.</p>
<h3><a class="anchor" id="io_subsec"></a>
I/O</h3>
<p>The Reranker framework uses protocol buffers for all low-level I/O. (See <a href="http://code.google.com/p/protobuf/">http://code.google.com/p/protobuf/</a> for more information.) In short, protocol buffers provide a way to serialize and de-serialize things that look a lot like C <code>struct</code>&rsquo;s. You specify a protocol buffer in a format very familiar to C/C++/Java programmers. The protocol buffer definitions for the Reranker framework are all specified in two files </p>
<div class="fragment"><pre class="fragment"> src/proto/data.proto 
</pre></div><p> and </p>
<div class="fragment"><pre class="fragment"> src/proto/model.proto 
</pre></div><p>While you might be interested in perusing these files for your own edification, the Reranker framework has reader and writer classes that abstract away from this low-level representation.</p>
<h3><a class="anchor" id="bootstrap_protobuf"></a>
Creating protocol buffer files</h3>
<p>You <em>do</em> need to get some candidate sets into this protocol buffer format to begin working with the Reranker framework, and so to bootstrap the process, you can use the executables in the <code>src/dataconvert</code> directory (see the <code>README</code> file in that directory for example usage). The <code>asr_nbest_proto</code> executable can read sets of files in Brian Roark&rsquo;s format, and the <code>mt_nbest_proto</code> can read files in Philipp Koehn&rsquo;s format.</p>
<p>What if you have files that are not in either of those two formats? The answer is that you can easily construct your own <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet </a> instances in memory and write them out to file, serialized using their protocol buffer equivalent, <code>CandidateSetMessage</code>. The only requirements are that each <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet </a> needs to have a reference string, and each <a class="el" href="classreranker_1_1_candidate.html">Candidate </a> needs to have a baseline score, a loss value, a string consisting of its tokens and the number of its tokens. Here are the two methods:</p>
<h4><a class="anchor" id="candidate_set_creation_1"></a>
Method 1: Batch</h4>
<p>This method creates a sequence of <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet </a> in memory, pushing each into an STL <code>std::vector</code>, and then writes that vector out to disk. Below is a rough idea of what your code would look like. The following invents methods/functions for grabbing the data for each new <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet </a> and <a class="el" href="classreranker_1_1_candidate.html">Candidate </a> and instance, and assumes you want to output to the file named by the variable <code>filename</code>. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;vector&gt;</span>
<span class="preprocessor"> #include &lt;tr1/memory&gt;</span>
<span class="preprocessor"> #include &quot;<a class="code" href="candidate-set_8_h.html" title="Class to hold a single training instance for a reranker, which is a set of examples, typically the n-best output of some input process, posibly including a gold-standard feature vector.">candidate-set.H</a>&quot;</span>
<span class="preprocessor"> #include &quot;<a class="code" href="candidate-set-writer_8_h.html" title="Class for writing streams of training or test instances, where each training or test instance is a re...">candidate-set-writer.H</a>&quot;</span>
 ...
 <span class="keyword">using</span> std::vector;
 <span class="keyword">using</span> std::tr1::shared_ptr;
 ...
 vector&lt;shared_ptr&lt;CandidateSet&gt; &gt; candidate_sets;
 <span class="keywordflow">while</span> (there_are_more_candidate_sets()) {
    <span class="keywordtype">string</span> reference = get_candidate_set_reference_string();
    shared_ptr&lt;CandidateSet&gt; candidate_set(<span class="keyword">new</span> CandidateSet());
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; number_of_candidates; ++i) {
      <span class="comment">// Assemble the data for current Candidate, build it and add it.</span>
      <span class="keywordtype">double</span> <a class="code" href="namespacehadoop-run.html#acccc808b1c10830f49ff1b785c460ddd">loss</a> = get_curr_candidate_loss();
      <span class="keywordtype">double</span> baseline_score = get_curr_candidate_baseline_score();
      <span class="keywordtype">int</span> num_tokens = get_curr_candidate_num_tokens();
      <span class="keywordtype">string</span> raw_data = get_curr_candidate_string();
      shared_ptr&lt;Candidate&gt; candidate(<span class="keyword">new</span> Candidate(i, loss, baseline_score,
                                                    num_tokens, raw_data));
      candidate_set-&gt;AddCandidate(candidate);
    }
    candidate_sets.push_back(candidate_set);
 }
 <span class="comment">// Finally, write out entire vector of CandidateSet instances.</span>
 CandidateSetWriter candidate_set_writer;
 <span class="keywordtype">bool</span> compressed = <span class="keyword">true</span>;
 <span class="keywordtype">bool</span> use_base64 = <span class="keyword">true</span>;
 candidate_set_writer.Write(candidate_sets, filename, compressed, use_base64);
</pre></div><h4><a class="anchor" id="candidate_set_creation_2"></a>
Method 2: Serial</h4>
<p>This method is nearly identical to <a class="el" href="index.html#candidate_set_creation_1">Method 1</a>, but does not try to assemble all <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet </a> into a single <code>std::vector</code> before writing them all out to disk. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;tr1/memory&gt;</span>
<span class="preprocessor"> #include &quot;<a class="code" href="candidate-set_8_h.html" title="Class to hold a single training instance for a reranker, which is a set of examples, typically the n-best output of some input process, posibly including a gold-standard feature vector.">candidate-set.H</a>&quot;</span>
<span class="preprocessor"> #include &quot;<a class="code" href="candidate-set-writer_8_h.html" title="Class for writing streams of training or test instances, where each training or test instance is a re...">candidate-set-writer.H</a>&quot;</span>
 ...
 <span class="keyword">using</span> std::tr1::shared_ptr;
 ...
 <span class="comment">// Set up CandidateSetWriter to begin serial writing to file.</span>
 <span class="keywordtype">bool</span> compressed = <span class="keyword">true</span>;
 <span class="keywordtype">bool</span> use_base64 = <span class="keyword">true</span>;
 CandidateSetWriter candidate_set_writer;
 candidate_set_writer.Open(filename, compressed, use_base64);
 <span class="keywordflow">while</span> (there_are_more_candidate_sets()) {
    <span class="keywordtype">string</span> reference = get_candidate_set_reference_string();
    CandidateSet candidate_set;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; number_of_candidates; ++i) {
      <span class="comment">// Assemble the data for current Candidate, build it and add it.</span>
      <span class="keywordtype">double</span> loss = get_curr_candidate_loss();
      <span class="keywordtype">double</span> baseline_score = get_curr_candidate_baseline_score();
      <span class="keywordtype">int</span> num_tokens = get_curr_candidate_num_tokens();
      <span class="keywordtype">string</span> raw_data = get_curr_candidate_string();
      shared_ptr&lt;Candidate&gt; candidate(<span class="keyword">new</span> Candidate(i, loss, baseline_score,
                                                    num_tokens, raw_data));
      candidate_set.AddCandidate(candidate);
    }
    <span class="comment">// Serialize this newly constructed CandidateSet to file.</span>
    candidate_set_writer.WriteNext(candidate_set);
 }
 candidate_set_writer.Close();
</pre></div><p>There&rsquo;s a third, secret method for reading in candidate sets from arbitrary formats. You can build an implementation of the rather simple <a class="el" href="classreranker_1_1_candidate_set_iterator.html">CandidateSetIterator </a> interface, which is what the <a class="el" href="classreranker_1_1_model.html">Model </a> interface uses to iterate over a sequence of candidate sets during training or decoding. With this approach, your data never gets stored as protocol buffer messages. Given the utility of storing information in protocol buffers, however, we strongly advise against using this method.</p>
<h3><a class="anchor" id="classes_subsec"></a>
Classes</h3>
<p>If you want to extract features, there are just four classes in the Reranker framework you&rsquo;ll want to know about: </p>
<table class="doxtable">
<tr>
<th>Class name</th><th>Brief description </th></tr>
<tr>
<td><a class="el" href="classreranker_1_1_candidate.html">Candidate </a> </td><td>Describes a candidate hypothesis put forth by a baseline model for some problem instance (<em>e.g.</em>, a sentence in the case of MT or an utterance in the case of speech recognition).   </td></tr>
<tr>
<td><a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet </a> </td><td>A set of candidate hypotheses for a single problem instance.  </td></tr>
<tr>
<td><a class="el" href="classreranker_1_1_feature_vector.html">FeatureVector </a> </td><td>A mapping from feature uid&rsquo;s (either <code>string</code>&rsquo;s or <code>int</code>&rsquo;s) to their values (<code>double</code>&rsquo;s).   </td></tr>
<tr>
<td><a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> </td><td><p class="starttd">An interface/abstract base class that you will extend to write your own feature extractors.  </p>
<p class="endtd"></p>
</td></tr>
</table>
<h3><a class="anchor" id="building_a_feat_extractor_subsec"></a>
Building a FeatureExtractor</h3>
<p>To build your own <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor</a>, follow these steps: </p>
<ol>
<li>
Create a class that derives from <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor</a>. </li>
<li>
<em>(optional)</em> Override the <a class="el" href="classreranker_1_1_factory_constructible.html#a4a45cf0a7822b3cd26ec882f0330b788">FeatureExtractor::RegisterInitializers </a> method in case your <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> needs to set certain of its data members when constructed by a <a class="el" href="classreranker_1_1_factory.html">Factory</a>. Also, one may override the <a class="el" href="classreranker_1_1_feature_extractor.html#a2ec99fbd293b35e90f9553a729e6f649">FeatureExtractor::Init </a> method if the feature extractor requires more object initialization after its data members have been initialized. See <a class="el" href="index.html#appendix_sec">Appendix: Dynamic object instantiation</a> for more information about how various objects are constructed via <a class="el" href="classreranker_1_1_factory.html">Factory</a> instances. </li>
<li>
Register your <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> using the <a class="el" href="feature-extractor_8_h.html#a7271aa7d6a37191a08c076a838c7ca36">REGISTER_FEATURE_EXTRACTOR</a> macro. This is also required to be able to construct your <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> by the <a class="el" href="classreranker_1_1_factory.html">Factory </a> class. </li>
<li>
Implement either the <a class="el" href="classreranker_1_1_feature_extractor.html#af1c46248eb454384594dc3fcb61b0e70">FeatureExtractor::Extract </a> or the <a class="el" href="classreranker_1_1_feature_extractor.html#aa35034d5100e4a2cbe83325cad6c4a6b">FeatureExtractor::ExtractSymbolic </a> method. See below for more information about implementing these methods. </li>
</ol>
<p>See <a class="el" href="example-feature-extractor_8_h.html">example-feature-extractor.H</a> for a fully-functional (albeit boring) <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> implementation. Please note that normally, one would use the <a class="el" href="feature-extractor_8_h.html#a7271aa7d6a37191a08c076a838c7ca36">REGISTER_FEATURE_EXTRACTOR</a> macro in one&rsquo;s feature extractor&rsquo;s <code>.C</code> file, but for the <a class="el" href="classreranker_1_1_example_feature_extractor.html">ExampleFeatureExtractor </a> this is done in the <code>.H</code> to keep things simple.</p>
<p>As mentioned in Step 4 above, in most cases, you&rsquo;ll either want to provide an implementation for the <a class="el" href="classreranker_1_1_feature_extractor.html#af1c46248eb454384594dc3fcb61b0e70">FeatureExtractor::Extract </a> or the <a class="el" href="classreranker_1_1_feature_extractor.html#aa35034d5100e4a2cbe83325cad6c4a6b">FeatureExtractor::ExtractSymbolic </a> methods, but not both. In fact, you&rsquo;ll most likely just want to implement <a class="el" href="classreranker_1_1_feature_extractor.html#aa35034d5100e4a2cbe83325cad6c4a6b">ExtractSymbolic</a>, which allows you to extract features that are <code>string</code>&rsquo;s that map to <code>double</code> values. (Since both methods are pure virtual in the <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> definition, you&rsquo;ll have to implement both, but either&mdash;or both&mdash;can be implemented to do nothing.)</p>
<p>When implementing the <a class="el" href="classreranker_1_1_feature_extractor.html#aa35034d5100e4a2cbe83325cad6c4a6b">FeatureExtractor::ExtractSymbolic </a> method, you will normally modify just the second parameter, which is a reference to a <a class="el" href="classreranker_1_1_feature_vector.html">FeatureVector&lt;string, double&gt;</a>. You&rsquo;ll typically modify it using the <a class="el" href="classreranker_1_1_feature_vector.html#a541f26184a4407f62eb5dad8102cf375">FeatureVector::IncrementWeight </a> method. (There&rsquo;s also a <a class="el" href="classreranker_1_1_feature_vector.html#ad94d388ef81023981d6924a2020268d2">FeatureVector::SetWeight </a> method, but that will blow away any existing weight for the specified feature, and so it should not normally be used.)</p>
<h3><a class="anchor" id="extract_features_subsec"></a>
Extracting Features (Finally!)</h3>
<p>If you want to extract features for an existing file containing serialized <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet </a> instances (again, for now, created using the tools in <code>src/dataconvert</code>), you can write a short configuration file that specifies which <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> implementations to instantiate at run-time and execute for each <a class="el" href="classreranker_1_1_candidate.html">Candidate </a> of each <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet</a>. (The <a class="el" href="classreranker_1_1_executive_feature_extractor.html">ExecutiveFeatureExtractor </a> class is responsible for &ldquo;executing&rdquo; the feature extraction from this user-specified suite of feature extractors, all of which are built by a <a class="el" href="classreranker_1_1_factory.html">Factory </a> inside the <a class="el" href="classreranker_1_1_executive_feature_extractor.html">ExecutiveFeatureExtractor</a>.)</p>
<p>An example of such a configuration file is <code>test-fe.config</code> in the directory <code>learning/reranker/config</code>. The format of a feature extractor configuration file should be a sequence of <em>specification strings</em>, each of which looks like </p>
<div class="fragment"><pre class="fragment"> FeatureExtractorClassName(init_string) 
</pre></div><p> Please see <a class="el" href="index.html#appendix_sec">Appendix: Dynamic object instantiation</a> for more details on factories and the ability to construct objects from specification strings. (For a formal, BNF description of the format of a <em>specification string</em>, please see the documentation for the <a class="el" href="classreranker_1_1_factory.html#adab5289badf4e9090ffe6b16413585ee">reranker::Factory::CreateOrDie</a> method.)</p>
<p>You can then pass this configuration file, along with one or more input files and an output directory, to the <code>bin/extract-features</code> executable. The executable will read the <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet </a> instances from the input files, and, for each <a class="el" href="classreranker_1_1_candidate.html">Candidate </a> in each <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet</a>, will run the <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor</a>&rsquo;s specified in the config file, in order, on that <a class="el" href="classreranker_1_1_candidate.html">Candidate</a>. The &ldquo;in order&rdquo; part is significant, if, <em>e.g.</em>, you have a <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> implementation that expressly uses features generated by a previously-run <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor</a>.</p>
<p>You can execute <code>extract-features</code> with no arguments to get the usage. Here&rsquo;s what your command will look like </p>
<div class="fragment"><pre class="fragment"> extract-features -c &lt;config file&gt; -i &lt;input file&gt;+ -o &lt;output directory&gt; 
</pre></div><p>Your input files will each be read in, new features will be extracted and then the resulting, modified streams of <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet </a> objects will be written out to a file of the same name in the <code>&lt;output directory&gt;</code>.</p>
<h3><a class="anchor" id="bonus_subsec"></a>
Bonus subsection: extracting features already sitting in a file</h3>
<p>If you generate features offline as a text file, where each line corresponds to the features for a single candidate hypothesis, you&rsquo;re in luck. There&rsquo;s an abstract base class called <a class="el" href="classreranker_1_1_abstract_file_backed_feature_extractor.html">AbstractFileBackedFeatureExtractor </a> that you can extend to implement a <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> that doesn&rsquo;t do any real work, but rather uses whatever it finds in its &ldquo;backing file&rdquo;. In fact, there's already a concrete implementation in the form of <a class="el" href="classreranker_1_1_basic_file_backed_feature_extractor.html">BasicFileBackedFeatureExtractor</a>, so you might be able to use that class &ldquo;as is&rdquo;.</p>
<p>Since the feature extractor configuration file lets you specify any sequence of <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> instances, you can mix and match, using some <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor</a>&rsquo;s that are truly computing feature functions &ldquo;on the fly&rdquo;, and others that are simply reading in pre-computed features sitting in a file.</p>
<h2><a class="anchor" id="training_a_model_sec"></a>
Training a model</h2>
<p>To train a model, you&rsquo;ll run the <code>bin/run-model</code> executable, which does both model training and inference on test data.</p>
<p>Here&rsquo;s a sample command: </p>
<div class="fragment"><pre class="fragment"> bin/run-model -t train_file1.gz train_file2.gz -d dev_file1.gz dev_file2.gz -m model_output_file.gz 
</pre></div><p>This builds a model based on the serialized <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet</a>&rsquo;s in <code>train_file1.gz</code> and <code>train_file2.gz</code>, using <code>dev_file1.gz</code> and <code>dev_file2.gz</code> for held-out evaluation (as a stopping criterion for the perceptron), outputting the model to <code>model.gz</code>. As with the <code>bin/extract-features</code> executable, running <code>bin/run-model</code> with no arguments prints out a detailed usage message.</p>
<p>Two options that are common to both the <code>bin/extract-features</code> and <code>bin/run-model</code> executables are worth mentioning: </p>
<ul>
<li>
The <code>--max-examples</code> option specifies the maximum number of training examples (<em>i.e.</em>, <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet </a> instances) to be read from each input file. </li>
<li>
The <code>--max-candidates</code> option specifies the maxiumum number of candidates to be read per <a class="el" href="classreranker_1_1_candidate_set.html">CandidateSet </a>. So, even if your input file contains, say, 1000-best hypothesis sets, you can effectively turn them into 100-best hypothesis sets by specifying <div class="fragment"><pre class="fragment"> --max-candidates 100 
</pre></div> on the command line. </li>
</ul>
<h2><a class="anchor" id="running_a_model_sec"></a>
Running a model</h2>
<p>So you&rsquo;ve trained a model and saved it to a file. Now what? To run a model on some data (<em>i.e.</em> to do inference), use the <code>bin/run-model</code> executable and supply the same command-line arguments as you would for <a class="el" href="index.html#training_a_model_sec">training</a>, except omit the training files that you would specify with the <code>-t</code> flag. In this mode, the model file specified with the <code>-m</code> flag is the name of the file from which to load a model that had been trained previously. That model will then be run on the &ldquo;dev&rdquo; data files you supply with the <code>-d</code> flag.</p>
<p>A command might look like this: </p>
<div class="fragment"><pre class="fragment"> bin/run-model -d dev_file1.gz dev_file2.gz -m model_input_file.gz 
</pre></div><h2><a class="anchor" id="appendix_sec"></a>
Appendix: Dynamic object instantiation</h2>
<p>There&rsquo;s a famous quotation of Philip Greenspun known as <a href="http://en.wikipedia.org/wiki/Greenspun&apos;s_Tenth_Rule">Greenspun&rsquo;s Tenth Rule</a>: </p>
<dl class="user"><dt><b>Greenspun&rsquo;s Tenth Rule</b></dt><dd>Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.</dd></dl>
<p>This statement is remarkably true in practice, and no less so here. C++ lacks convenient support for dynamic object instantiation, but the Reranker Framework uses it extensively via a <a class="el" href="classreranker_1_1_factory.html">Factory </a> class and a C++-style (yet simple) syntax.</p>
<h3><a class="anchor" id="appendix_cpp_example"></a>
An example: The way C++ does it</h3>
<p>To motivate the C++-style syntax used by the Reranker Framework&rsquo;s <a class="el" href="classreranker_1_1_factory.html">Factory </a> class, let&rsquo;s look at a simple example of a C++ class <code>Person</code> and its constructor: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// A class to represent a date in the standard Gregorian calendar.</span>
 <span class="keyword">class </span>Date {
  <span class="keyword">public</span>:
    Date(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day) :
      year_(year), month_(month), day_(day) { }
  <span class="keyword">private</span>:
    <span class="keywordtype">int</span> year_;
    <span class="keywordtype">int</span> month_;
    <span class="keywordtype">int</span> day_;
 };

 <span class="comment">// A class to represent a few facts about a person.</span>
 <span class="keyword">class </span>Person {
  <span class="keyword">public</span>:
    Person(<span class="keyword">const</span> <span class="keywordtype">string</span> &amp;name, <span class="keywordtype">int</span> cm_height, <span class="keyword">const</span> Date &amp;birthday) :
      name_(name), cm_height_(cm_height), birthday_(birthday) { }
  <span class="keyword">private</span>:
   <span class="keywordtype">string</span> name_;
   <span class="keywordtype">int</span> cm_height_;
   Date birthday_;
 };
</pre></div><p> As you can see, the <code>Person</code> class has three data members, one of which happens to be an instance of another class called <code>Date</code>. In this case, all of the initialization of a <code>Person</code> happens in the <em>initialization phase</em> of the constructor&mdash;the part after the colon but before the <em>declaration phase</em> block. By convention, each parameter to the constructor has a name nearly identical to the data member that will be initialized from it. If we wanted to construct a <code>Person</code> instance for someone named &ldquo;Fred&rdquo; who was 180 cm tall and was born January 10th, 1990, we could write the following: </p>
<div class="fragment"><pre class="fragment">   Person fred(<span class="stringliteral">&quot;Fred&quot;</span>, 180, Date(1990, 1, 10));
</pre></div><p>If <code>Person</code> were a <a class="el" href="classreranker_1_1_factory.html">Factory</a>-constructible type in the Reranker Framework, we would be able to specify the following as a <em>specification string</em> to tell the <a class="el" href="classreranker_1_1_factory.html">Factory </a> how to construct a <code>Person</code> instance for Fred: </p>
<div class="fragment"><pre class="fragment">   Person(name(<span class="stringliteral">&quot;Fred&quot;</span>), cm_height(180), birthday(Date(year(1990), month(1), day(10))))
</pre></div><p> As you can see, the syntax is very similar to that of C++. It&rsquo;s kind of a combination of the parameter list and the initialization phase of a C++ constructor. Unfortunately, we can&rsquo;t get this kind of dynamic instantiation in C++ for free; we need some help from the programmer. However, we&rsquo;ve tried to make the burden on the programmer fairly low, using just a couple of macros to help declare a <a class="el" href="classreranker_1_1_factory.html">Factory </a> for an abstract base class, as well as to make it easy to make that <a class="el" href="classreranker_1_1_factory.html">Factory </a> aware of the concrete subtypes of that base class that it can construct.</p>
<h3><a class="anchor" id="appendix_details"></a>
Some nitty gritty details: declaring factories for abstract types and registering concrete subtypes</h3>
<p>Every <a class="el" href="classreranker_1_1_factory.html">Factory</a>-constructible abstract type needs to declare its factory via the <a class="el" href="factory_8_h.html#a01b208854b036ee1381a9289186ff3c2">IMPLEMENT_FACTORY</a> macro. For example, since the Reranker Framework uses a <a class="el" href="classreranker_1_1_factory.html">Factory </a> to construct concrete instances of the abstract type <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a>, the line </p>
<div class="fragment"><pre class="fragment">   <a class="code" href="factory_8_h.html#a01b208854b036ee1381a9289186ff3c2" title="Provides the necessary implementation for a factory for the specified BASE class type.">IMPLEMENT_FACTORY</a>(FeatureExtractor)
</pre></div><p> appears in the file <code><a class="el" href="feature-extractor_8_c.html" title="Feature extractor interface and factory implementation.">feature-extractor.C</a></code>. (It is unfortunate that we have to resort to using macros, but the point is that the burden on the programmer to create a factory is extremely low, and therefore so is the risk of introducing bugs.)</p>
<p>By convention every <a class="el" href="classreranker_1_1_factory.html">Factory</a>-constructible abstract type defines one or two macros in terms of the <a class="el" href="factory_8_h.html#a0b09e4aaef613d7556c07875c7d5a029">REGISTER_NAMED</a> macro defined in <a class="el" href="factory_8_h.html">factory.H</a> to allow concrete subtypes to register themselves with the <a class="el" href="classreranker_1_1_factory.html">Factory</a>, so that they may be instantiated. For example, since the <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> class is an abstract base class in the Reranker Framework that has a <a class="el" href="classreranker_1_1_factory.html">Factory</a>, in <a class="el" href="feature-extractor_8_h.html" title="Provides the reranker::FeatureExtractor interface.">feature-extractor.H</a> you can find the declaration of two macros, <a class="el" href="feature-extractor_8_h.html#a8112c975d39ef4d6f25719d719c52852">REGISTER_NAMED_FEATURE_EXTRACTOR</a> and <a class="el" href="feature-extractor_8_h.html#a7271aa7d6a37191a08c076a838c7ca36">REGISTER_FEATURE_EXTRACTOR</a>. The <a class="el" href="classreranker_1_1_ngram_feature_extractor.html">NgramFeatureExtractor </a> class is a concrete subclass of <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor</a>, and so it registers itself with <a class="el" href="classreranker_1_1_factory.html">Factory</a>&lt;<a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor</a>&gt; by having </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="feature-extractor_8_h.html#a7271aa7d6a37191a08c076a838c7ca36" title="Registers the FeatureExtractor  with the specified subtype TYPE with the FeatureExtractor  Factory...">REGISTER_FEATURE_EXTRACTOR</a>(NgramFeatureExtractor) 
</pre></div><p> in <code><a class="el" href="ngram-feature-extractor_8_c.html" title="Provides the implementation of the reranker::NgramFeatureExtractor class.">ngram-feature-extractor.C</a></code>. That macro expands to </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="factory_8_h.html#a0b09e4aaef613d7556c07875c7d5a029" title="This macro registers the concrete subtype TYPE with the specified factory for instances of type BASE;...">REGISTER_NAMED</a>(NgramFeatureExtractor, NgramFeatureExtractor,
 FeatureExtractor) 
</pre></div><p> which tells the <a class="el" href="classreranker_1_1_factory.html">Factory</a>&lt;FeatureExtractor&gt; that there is a class <code>NgramFeatureExtractor</code> whose &ldquo;factory name&rdquo; (the string that can appear in <em>specification strings</em>&mdash;more on these in a moment) is <code>"NgramFeatureExtractor"</code> and that the class <a class="el" href="classreranker_1_1_ngram_feature_extractor.html">NgramFeatureExtractor </a> is a concrete subclass of <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a>, <em>i.e.</em>, that it can be constructed by <code>Factory&lt;FeatureExtractor&gt;</code>, as opposed to some other <code>Factory</code> for a different abstract base class.</p>
<p>Every <a class="el" href="classreranker_1_1_factory.html">Factory</a>-constructible abstract type must also specify two methods, a <code>RegisterInitializers(Initializers&amp;)</code> method and an <code>Init(const string&amp;)</code> method. Both methods are guaranteed to be invoked, in order, just after construction of every object by the <a class="el" href="classreranker_1_1_factory.html">Factory</a>. To reduce the burden on the programmer, you can derive your abstract class from <a class="el" href="classreranker_1_1_factory_constructible.html">FactoryConstructible </a>, which implements both methods to do nothing. (All of the abstract base classes that can be constructed via Factory in the Reranker Framework already do this.) For most concrete subtypes, most of the work of initialization is done inside the factory to initialize registered data members, handled by the class&rsquo;s <code>RegisterInitializers(Initializers&amp;)</code> method. The implementation of this method generally contains a set of invocations to the various <code>Add</code> methods of the <a class="el" href="classreranker_1_1_initializers.html">Initializers </a> class, &ldquo;registering&rdquo; each variable with a name that will be recognized by the <a class="el" href="classreranker_1_1_factory.html">Factory </a> when it parses the specification string. When member initializations are added to an <a class="el" href="classreranker_1_1_initializers.html">Initializers </a> instance, they are optional by default. By including a third argument that is <code>true</code>, one may specify a member whose initialization string <em>must</em> appear within the specification. If it does not contain it, a runtime error will be raised.</p>
<p>For completeness, post&ndash;member-initialization may be performed by the class&rsquo;s <code>Init(const string &amp;)</code> method, which is guaranteed to be invoked with the complete string that was parsed by the <a class="el" href="classreranker_1_1_factory.html">Factory</a>. The code executed by a class&rsquo; <code>Init(cosnt string &amp;)</code> method is very much akin to the <em>declaration phase</em> of a C++ constructor, because it is the code that gets executed just after the members have been initialized.</p>
<p>For example, <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> instances are <a class="el" href="classreranker_1_1_factory.html">Factory</a>-constructible, and so the <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor </a> class ensures its concrete subclasses have a <a class="el" href="classreranker_1_1_factory_constructible.html#a4a45cf0a7822b3cd26ec882f0330b788">RegisterInitializers </a> method and an <a class="el" href="classreranker_1_1_feature_extractor.html#a2ec99fbd293b35e90f9553a729e6f649">Init </a> method by being a subclass of <a class="el" href="classreranker_1_1_factory_constructible.html">reranker::FactoryConstructible</a>. As we saw above, <a class="el" href="classreranker_1_1_ngram_feature_extractor.html">NgramFeatureExtractor </a> is a concrete subtype of <a class="el" href="classreranker_1_1_feature_extractor.html">FeatureExtractor</a> . That class has two data members that can be initialized by a factory, one required and one optional. To show you how easy it is to &ldquo;declare&rdquo; data members that need initialization, here is the exact code from the <a class="el" href="classreranker_1_1_ngram_feature_extractor.html#a6774904d88f979c8c8246883eb25fbd9">NgramFeatureExtractor::RegisterInitializers </a> method: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> RegisterInitializers(Initializers &amp;initializers) {
   <span class="keywordtype">bool</span> required = <span class="keyword">true</span>;
   initializers.Add(<span class="stringliteral">&quot;n&quot;</span>,      &amp;n_, required);
   initializers.Add(<span class="stringliteral">&quot;prefix&quot;</span>, &amp;prefix_);
 }
</pre></div><p> The above code says that the <a class="el" href="classreranker_1_1_ngram_feature_extractor.html">NgramFeatureExtractor </a> has a data member <code>n_</code>, which happens to be an <code>int</code>, that is required to be initialized when an <a class="el" href="classreranker_1_1_ngram_feature_extractor.html">NgramFeatureExtractor </a> instance is constructed by a <a class="el" href="classreranker_1_1_factory.html">Factory</a>, and that the name of this variable will be <code>"n"</code> as far as the factory is concerned. It also says that it has a data member <code>prefix_</code>, which happens to be of type <code>string</code>, whose factory name will be <code>"prefix"</code>, and that is not required to be present in a <em>specification string</em> for an <a class="el" href="classreranker_1_1_ngram_feature_extractor.html">NgramFeatureExtractor</a>.</p>
<h3><a class="anchor" id="appendix_language"></a>
The Factory language</h3>
<p>As we&rsquo;ve seen, the language used to instantiate objects is quite simple. An object is constructed via a <em>specification string</em> of the following form: </p>
<div class="fragment"><pre class="fragment"> RegisteredClassName(member1(init1), member2(init2), ...) 
</pre></div><p> where <code>RegisteredClassName</code> is the concrete subtype&rsquo;s name specified with the <a class="el" href="factory_8_h.html#a0b09e4aaef613d7556c07875c7d5a029">REGISTER_NAMED</a> macro (or, more likely, one of the convenience macros that is &ldquo;implemented&rdquo; in terms of the <a class="el" href="factory_8_h.html#a0b09e4aaef613d7556c07875c7d5a029">REGISTER_NAMED</a> macro, such as <a class="el" href="model_8_h.html#a9ebfdbfca885b4b3db9fd5936dcfa553">REGISTER_MODEL</a> or <a class="el" href="feature-extractor_8_h.html#a7271aa7d6a37191a08c076a838c7ca36">REGISTER_FEATURE_EXTRACTOR</a>). The comma-separated list inside the outermost set of parentheses is the set of <em>member initializations</em>, which looks, as we saw <a class="el" href="index.html#appendix_cpp_example">above</a>, intentionally similar to the format of a C++ constructor&rsquo;s initialization phase. The names of class members that can be initialized are specified via repeated invocations of the various overloaded <a class="el" href="classreranker_1_1_initializers.html">reranker::Initializers</a> <code>Add</code> methods. There is essentially one <code>Add</code> method per primitive C++ type, as well as an <code>Add</code> method for <a class="el" href="classreranker_1_1_factory.html">Factory</a>-constructible types.</p>
<p>If you love Backus-Naur Form specifications, please see the documentation for the <a class="el" href="classreranker_1_1_factory.html#adab5289badf4e9090ffe6b16413585ee">Factory::CreateOrDie </a> method for the formal description of the grammar for specification strings.</p>
<p>To continue our example with <a class="el" href="classreranker_1_1_ngram_feature_extractor.html">NgramFeatureExtractor </a>, the following are all legal specification strings for constructing <a class="el" href="classreranker_1_1_ngram_feature_extractor.html">NgramFeatureExtractor </a> instances: </p>
<div class="fragment"><pre class="fragment"> NgramFeatureExtractor(n(3))
 NgramFeatureExtractor(n(2), prefix(&quot;foo:&quot;))
 NgramFeatureExtractor(prefix(&quot;bar&quot;), n(4))
 NgramFeatureExtractor(n(2),)
</pre></div><p> As you can see, the order of member initializers is not important (because each has a unique name), and you can optionally put a comma after the last initializer. The following are <em><b>illegal</b></em> specification strings for <a class="el" href="classreranker_1_1_ngram_feature_extractor.html">NgramFeatureExtractor </a> instances: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Illegal specification strings:</span>
 NgramFeatureExtractor(prefix(<span class="stringliteral">&quot;foo&quot;</span>))
 NgramFeatureExtractor()
 NgramFeatureExtractor(n(3), prefix(4))
</pre></div><p> In the first two cases, the specification strings are missing the required variable <code>n</code>, and in the final case, the optional <code>prefix</code> member is being initialized, but with an <code>int</code> literal instead of a <code>string</code> literal.</p>
<p>In most cases, you will never need to directly use a <a class="el" href="classreranker_1_1_factory.html">Factory </a> instance, but they are often at work behind the scenes. For example, every <a class="el" href="classreranker_1_1_model.html">Model </a> instance uses a factory to construct its internal <a class="el" href="classreranker_1_1_candidate_1_1_comparator.html">Candidate::Comparator </a> instances that it uses to determine the &ldquo;gold&rdquo; and top-scoring candidates when training. In fact, the <em>specification strings</em> for constructing <a class="el" href="classreranker_1_1_model.html">Model </a> instances reveal how an <code>init_string</code> can itself contain other <em>specification strings</em>. For example, to construct a <a class="el" href="classreranker_1_1_perceptron_model.html">PerceptronModel </a> instance with a <a class="el" href="classreranker_1_1_direct_loss_score_comparator.html">DirectLossScoreComparator </a>, you&rsquo;d use the following specification string: </p>
<div class="fragment"><pre class="fragment"> PerceptronModel(name(<span class="stringliteral">&quot;MyPerceptronModel&quot;</span>), score_comparator(DirectLossScoreComparator())) 
</pre></div><p>The first member initialization, for the member called <code>name</code>, specifies the unique name you can give to each <a class="el" href="classreranker_1_1_model.html">Model </a> instance (which is strictly for human consumption). The second member initialization, for the member called <code>score_comparator</code>, overrides the default <a class="el" href="classreranker_1_1_candidate_1_1_comparator.html">Candidate::Comparator </a> used to compare candidate scores, and illustrates how this simple language is recursive, in that specification strings may contain other specification strings for other Factory-constructible objects.</p>
<h3><a class="anchor" id="appendix_putting_together"></a>
Putting it all together</h3>
<p>Here is a template illustrating how one creates a <a class="el" href="classreranker_1_1_factory.html">Factory </a> for an abstract base class called &ldquo;<code>Abby</code>&rdquo; and declares a concrete subtype &ldquo;<code>Concky</code>&rdquo; to that Factory. Most users of the Reranker Framework are likely only to build concrete subtypes of abstract classes that already have factories, and so those users can safely ignore the <code>abby.H</code> and <code>abby.C</code> files. </p>
<ul>
<li>
<code>abby.H</code> <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &quot;<a class="code" href="factory_8_h.html" title="Provides a generic dynamic object factory.">factory.H</a>&quot;</span>
 <span class="keyword">class </span>Abby : <span class="keyword">public</span> FactoryConstructible {
   <span class="comment">// .. the code for Abby ...</span>
 };
<span class="preprocessor"> #define REGISTER_NAMED_ABBY(TYPE,NAME) REGISTER_NAMED(TYPE,NAME,Abby)</span>
<span class="preprocessor"> #define REGISTER_ABBY(TYPE) REGISTER_NAMED_ABBY(TYPE,TYPE)</span>
</pre></div> </li>
<li>
<code>abby.C</code> <div class="fragment"><pre class="fragment"> <a class="code" href="factory_8_h.html#a01b208854b036ee1381a9289186ff3c2" title="Provides the necessary implementation for a factory for the specified BASE class type.">IMPLEMENT_FACTORY</a>(Abby)
</pre></div> </li>
<li>
<code>concky.H</code> <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &quot;abby.H&quot;</span>
 <span class="keyword">class </span>Concky : <span class="keyword">public</span> Abby {
  <span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> RegisterInitializers(Initialiizers &amp;initializers) {
       <span class="comment">// various calls to the overloaded Initializers::Add methods,</span>
       <span class="comment">// one per data member that the Factory can initialize</span>
    }
 };
</pre></div> </li>
<li>
<code> concky.C </code> <div class="fragment"><pre class="fragment"> REGISTER_ABBY(Concky)
</pre></div> </li>
</ul>
<p>So what about Greenspun&rsquo;s Tenth Rule? Well, the idea that initialization strings can themselves contain specification strings suggests that there is a full-blown language being interpreted here, complete with a proper tokenizer and a recursive-descent parser. There is. It is a simple language, and one that is formally specified. To the extent that it mirrors the way C++ does things, it is not quite <em>ad hoc</em>; rather, it is (close to being) an exceedingly small subset of C++ that can be executed dynamically. We <em>hope</em> it is not bug-ridden, but we&rsquo;ll let you, the user, be the judge of that. </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 4 2013 16:17:30 for Reranker Framework (ReFr) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
